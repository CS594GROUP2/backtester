import numpy as np
import pandas as pd
import numba as nb 

# HELPER FUNCTIONS

@nb.jit(nopython=True)
def generate_random(size, entp, extp):
    """
    generates random trading signals (Numba Accelerated)

    Paramters:
    size: the size of the dataset
    entp: the entry probability
    extp: the exit probability

    Returns:
    a NumPy array of trading signals
    """
    random_signals = np.zeros(shape=size, dtype=np.int8)
    random_values = np.random.random(size)
    in_position = False

    # iterate through array, going in and out of position based on the random values
    for i in range(random_signals.size):
        if in_position:
            if extp > random_values[i]:
                random_signals[i] = -1
                in_position = False
        else:
            if entp > random_values[i]:
                random_signals[i] = 1
                in_position = True
    
    return random_signals

@nb.jit(nopython=True)
def generate_signals(price_data_np, target_np):
    """
    Numba accelerated helper function for generate_above_below

    Paramters:
    price_data_np: a NumPy array of price data
    target_np: a NumPy array of crossover values

    Returns:
    a NumPy array of trading signals
    """
    signals = np.zeros_like(price_data_np, dtype=np.int8)
    in_position = False

    # iterate through grabbing items from prifce_data_np and target_np
    for i in range(1, price_data_np.size):
        if target_np[i] == 0:
            pass
        if price_data_np[i] > target_np[i] and not in_position:
            signals[i] = 1
            in_position = True
        elif price_data_np[i] < target_np[i] and in_position:
            signals[i] = -1
            in_position = False
        else:
            pass
    
    return signals

class SignalGenerator:
    """
    a class used for generating trading signals but also
    fully encaspulating a trading strategy

    Attributes:
    price_data: a Pandas Series containing the price data
    metadata: a Dict containing the metadata for the price data, included in get_results()
    trading_signals: a NumPy array of trading signals

    Methods:
    generate_random: generates random trading signals
    generate_above_below: generates trading signals based on a crossover value
    get_results: returns the trading signals, price data, and metadata
    """

    def __init__(self, price_data, metadata={}):
        """
        Constructor for the SignalGenerator class

        Parameters:
        price_data: a Pandas Series containing the price data to be used in the trading strategy
        metadata: a Dict containing the metadata for the price data start, end, interval, and symbol
            new metadata will be added as it is generated by the trading strategy
        trading_signals: a NumPy array of trading signals
        """
        self.price_data : pd.Series = price_data
        self.metadata : dict = metadata
        self.trading_signals : np.ndarray = None

    def generate_random(self, size, entry_probability, exit_probability) -> np.ndarray:
        """
        Returns random trading strategy for a given size, entry and exit probability.

        Parameters:
        size: The size of the dataset.
        entry_probability: Float from 0 to 1 that indicates the chance that the random strategy will enter a position.
        exit_probability: Float from 0 to 1 that indicates the chance that the random strategy will leave a position.
        Returns:
        An array of trading signals that reflect a random trading strategy.
        """

        # Exceptions:
        if size <= 0:
            raise ValueError("Size must be greater than 0")
        if entry_probability < 0 or entry_probability > 1:
            raise ValueError("entry_probability must be between 0 and 1")
        if exit_probability < 0 or exit_probability > 1:
            raise ValueError("exit_probability must be between 0 and 1")
        
        # update the metadata
        self.metadata = {
            "random_signals": True
        }

        self.trading_signals = generate_random(size, entry_probability, exit_probability)

        return self.trading_signals

    def generate_above_below(self, target, metadata={}) -> np.ndarray:
        """
        Generates trading signals and stores them in a newly generated numpy array
        a positive trading signal(+1) is generated when the price crosses above the target
        a negative trading signal(-1) is generated when the price crosses below the target
        it is assumed to start not already in a position
        

        Args:
        target: a Pandas Series containing the target data crossover values
        metadata: a Dict containing the metadata for the technical indicator
        
        Returns:
        a NumPy array of trading signals
        """

        # validate the price data (defensive programming)
        if not isinstance(self.price_data, pd.Series):
            raise ValueError("The price data is not a Pandas Series")
        
        # validate the target data
        if not isinstance(target, pd.Series):
            raise ValueError("The target data is not a Pandas Series")
        
        # update the metadata
        self.metadata = metadata

        # numba only works with numpy arrays
        price_data_np = self.price_data.to_numpy()
        target_np = target.to_numpy()
        
        self.trading_signals = generate_signals(price_data_np, target_np)

        return self.trading_signals

    def get_results(self) -> dict:
        """
        Returns:
        A list containing:
        a Numpy array of trading signals
        a Numpy array of the price data
        a List of metadata
        """

        results = {
            "trading_signals": self.trading_signals,
            "price_data": self.price_data,
            "metadata": self.metadata
        }

        return results